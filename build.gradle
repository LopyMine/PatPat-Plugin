import me.modmuss50.mpp.ReleaseType

plugins {
	id("java")
	id("xyz.jpenilla.run-paper") version "2.3.0"
	id("me.modmuss50.mod-publish-plugin") version "0.7.4"
}

group = prop("plugin_maven_group")
version = prop("plugin_version")

base {
	archivesName = prop("plugin_name")
}

repositories {
	mavenCentral()
	maven {
		name = "spigotmc-repo"
		url = "https://hub.spigotmc.org/nexus/content/repositories/snapshots/"
	}
	maven {
		name = "sonatype"
		url = "https://oss.sonatype.org/content/groups/public/"
	}
}

dependencies {
	// Spigot API
	compileOnly("org.spigotmc:spigot-api:${prop("spigot-api")}")

	// Lombok
	compileOnly("org.projectlombok:lombok:${prop("lombok-version")}")
	annotationProcessor("org.projectlombok:lombok:${prop("lombok-version")}")

	// Jetbrains Annotations
	implementation("org.jetbrains:annotations:${prop("jetbrains-annotations")}")
}

def targetJavaVersion = prop("java_version") as int
def javaVersion = JavaVersion.toVersion(targetJavaVersion)

java {
	sourceCompatibility = javaVersion
	targetCompatibility = javaVersion
	if (JavaVersion.current() < javaVersion) {
		toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8'

	if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
		options.release.set(targetJavaVersion)
	}
}

processResources {
	def props = [:]
	props.put("version", prop("plugin_version"))

	props.each { key, value ->
		inputs.property key, value
	}

	filteringCharset 'UTF-8'
	filesMatching('plugin.yml') {
		expand(props)
	}
}

tasks.register('reBuild', Delete) {
	group("build")
	delete(project.rootProject.layout.buildDirectory.file("libs/${prop("plugin_name")}-${version}.jar"))
	finalizedBy("build")
}

runServer {
	minecraftVersion(prop("minecraft_version").toString())
}

publishMods {
	def loaders = prop("loaders").toString().split(" ")
	def modrinthProjectId = prop("modrinth_id").toString()
	def embedsDepends = prop("embeds").toString().split(" ")
	def curseForgeProjectId = prop("curseforge_id").toString()
	def requiresDepends = prop("requires").toString().split(" ")
	def optionalDepends = prop("optional").toString().split(" ")
	def endSupportedVersion = prop("end_supported_version").toString()
	def incompatibleDepends = prop("incompatible").toString().split(" ")
	def startSupportedVersion = prop("start_supported_version").toString()
	def versionTypeProperty = prop("version_type").toString().replace("RELEASE", "STABLE")
	def maxJavaVersion = JavaVersion.toVersion(prop("max_java_version"))
	def isClient = Boolean.parseBoolean(prop("is_for_client)").toString())
	def isTesting = Boolean.parseBoolean(prop("test_publish)").toString())
	def isServer = Boolean.parseBoolean(prop("is_for_server)").toString())
	def versionName = "[${startSupportedVersion}-${endSupportedVersion}] ${prop("plugin_name")} v${prop("plugin_version")}"
	def bl = providers.environmentVariable("CURSEFORGE_API_KEY").getOrNull() == null
	def bl2 = providers.environmentVariable("MODRINTH_API_KEY").getOrNull() == null
	def bl3 = isTesting || bl || bl2

	println "[PublishMods] [INFO] Configuring '${versionName}' for publishing"

	displayName = versionName
	file = getVerifiedOrDefaultJar(prop("plugin_name"), prop("plugin_version"))
	changelog = getChangeLog()
	type = ReleaseType.of(versionTypeProperty)
	modLoaders.addAll(loaders)
	dryRun = bl3

	if (bl3) {
		println "[PublishMods] [WARNING] Test Mode is Enabled!"
	}

//	curseforge {
//		projectId = curseForgeProjectId
//		accessToken = providers.environmentVariable("CURSEFORGE_API_KEY")
//
//		for (i in javaVersion.ordinal()..<maxJavaVersion.ordinal() + 1) {
//			javaVersions.add(JavaVersion.values()[i])
//		}
//
//		clientRequired = isClient
//		serverRequired = isServer
//
//	if (startSupportedVersion != endSupportedVersion) {
//		minecraftVersionRange {
//			start = startSupportedVersion
//			end = endSupportedVersion
//		}
//	} else {
//		minecraftVersions.add(endSupportedVersion)
//	}
//
//		if (requiresDepends.first() != "none") {
//			requires(requiresDepends)
//		}
//		if (optionalDepends.first() != "none") {
//			optional(optionalDepends)
//		}
//		if (incompatibleDepends.first() != "none") {
//			incompatible(incompatibleDepends)
//		}
//		if (embedsDepends.first() != "none") {
//			embeds(embedsDepends)
//		}
//	}

	modrinth {
		displayName = "${prop("plugin_name")} v${prop("plugin_version")}"
		projectId = modrinthProjectId
		accessToken = providers.environmentVariable("MODRINTH_API_KEY")

		if (startSupportedVersion != endSupportedVersion) {
			minecraftVersionRange {
				start = startSupportedVersion
				end = endSupportedVersion
			}
		} else {
			minecraftVersions.add(endSupportedVersion)
		}

		if (requiresDepends.first() != "none") {
			requires(requiresDepends)
		}
		if (optionalDepends.first() != "none") {
			optional(optionalDepends)
		}
		if (incompatibleDepends.first() != "none") {
			incompatible(incompatibleDepends)
		}
		if (embedsDepends.first() != "none") {
			embeds(embedsDepends)
		}
	}
}

def getVerifiedOrDefaultJar(String pluginName, String pluginVersion) {
	def path = "libs/${pluginName}-${pluginVersion}.jar"
	def provider = project.rootProject.layout.buildDirectory.file(path)
	def regularFile = provider.orNull
	if (regularFile == null || !regularFile.getAsFile().exists()) {
		println "[PublishMods] Failed to find jar file at '${path}'! Using archive file!"
		return jar.archiveFile
	}
	return regularFile.getAsFile()
}

String getChangeLog() {
	def file = project.rootProject.file("publish/CHANGELOG.md")
	if (file.exists()) {
		def text = file.getText()
		if (!text.isBlank()) {
			return text
		}
	}
	return "No changelog specified."
}

String prop(String key) {
	return findProperty(key).toString()
}